use super::*;

#[test]
fn test_data_segment_with_one_element() {
    let mut builder = DataSegmentBuilder::new();

    builder.add_data("hello".to_string(), "world".to_string());

    let result = builder.build_source();
    let expected = ".section data\n  .hello \"world\"\n";

    assert_eq!(result, expected);
}

#[test]
fn test_data_segment_with_no_elements() {
    let mut builder = DataSegmentBuilder::new();

    let result = builder.build_source();
    let expected = ""; // no data segment

    assert_eq!(result, expected);
}

#[test]
fn test_data_segment_with_multiple_elements() {
    let mut builder = DataSegmentBuilder::new();

    builder.add_data("hello".to_string(), "world".to_string());
    builder.add_data("foo".to_string(), "bar".to_string());

    let result = builder.build_source();
    let expected = ".section data\n  .hello \"world\"\n  .foo \"bar\"\n";

    assert_eq!(result, expected);
}

// TODO: test that data is sorted by name

#[test]
fn test_nop_instruction_builder() {
    let mut builder = InstructionBuilder::new("nop".to_string());

    let result = builder.build_source();
    let expected = "nop";

    assert_eq!(result, expected);
}

#[test]
fn test_move_instruction_builder() {
    let mut builder = InstructionBuilder::new("mov".to_string());

    builder.add_operand("(0x70)".to_string());
    builder.add_operand("0x24".to_string());

    let result = builder.build_source();
    let expected = "mov (0x70) 0x24";

    assert_eq!(result, expected);
}

#[test]
fn test_build_empty_program() {
    let mut builder = AssemblyBuilder::new();

    let result = builder.build_source();
    let expected = ";; Clasm program generated by Clasp Compiler\nend\n";

    assert_eq!(result, expected);
}

#[test]
fn test_build_program_with_one_instruction() {
    let mut builder = AssemblyBuilder::new();

    builder.add_instruction(InstructionBuilder::new("nop".to_string()));

    let result = builder.build_source();
    let expected = ";; Clasm program generated by Clasp Compiler\nnop\nend\n";

    assert_eq!(result, expected);
}

#[test]
fn test_build_program_with_one_instruction_and_data() {
    let mut builder = AssemblyBuilder::new();

    builder.add_instruction(InstructionBuilder::new("nop".to_string()));

    builder
        .data_segment()
        .add_data("hello".to_string(), "world".to_string());

    let result = builder.build_source();
    let expected = ";; Clasm program generated by Clasp Compiler\nnop\n\
    end\n.section data\n  .hello \"world\"\n";

    assert_eq!(result, expected);
}

#[test]
fn test_generate_hello_world_assembly() -> Result<(), AssemblyGenerationError> {
    // Compile the source code
    let program_text = "(fn main (println \"hello\"))".to_string();
    let tokens = clasp_parsing::tokenization::tokenize(&program_text).unwrap();
    let ast = clasp_parsing::parsing::parse_tree(tokens).unwrap();

    // Extract the statement
    assert_eq!(1, ast.get_expressions().len());
    let statement = match ast.get_expressions()[0].clone() {
        Expression::Statement(statement) => statement,
        _ => panic!("Expected Expression::Statement")
    };

    let expected_assembly = ";; Clasm program generated by Clasp Compiler\n\
    :main\ncall :println .d0000\nreturn\n.section data\n  .d0000 \"hello\"\n";

    let mut builder = AssemblyBuilder::new();
    builder.generate_statement_assembly(statement)?;

    let result = builder.build_source();
    println!("{}", result);
    assert_eq!(result, expected_assembly);

    Ok(())
}
