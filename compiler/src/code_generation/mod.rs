#[cfg(test)]
mod tests;

mod clasp_std;

use crate::parsing::ast::{Ast, Expression, Literal, Statement};

#[derive(Debug, Clone, PartialEq)]
pub enum AssemblyGenerationError {
    ExpectedStatement,
    ExpectedSpecificStatement(String),
    ExpectedIdentifierForFunctionName,
    NestedFunctionNotAllowed,
    #[allow(dead_code)]
    NotImplemented
}
use AssemblyGenerationError::*;

pub struct AssemblyBuilder {
    instructions: Vec<InstructionBuilder>,
    data_segment: DataSegmentBuilder
}

pub struct InstructionBuilder {
    operator: String,
    operands: Vec<String>
}

struct DataSegmentBuilder {
    data: Vec<(String, String)> // name, value
}

impl AssemblyBuilder {
    pub fn new() -> AssemblyBuilder {
        AssemblyBuilder {
            instructions: Vec::new(),
            data_segment: DataSegmentBuilder::new()
        }
    }

    pub fn add_instruction(&mut self, instruction: InstructionBuilder) {
        self.instructions.push(instruction);
    }

    pub fn build_source(self) -> String {
        let mut source = String::new();
        source.push_str(";; Clasm program generated by Clasp Compiler\n");

        for instruction in self.instructions {
            source.push_str(&format!("{}\n", instruction.build_source()));
        }

        source.push_str("end\n");

        source.push_str(&self.data_segment.build_source());

        source
    }

    fn format_literal(&mut self, literal: &Literal) -> String {
        match literal {
            Literal::Number(number) => format!("({})", number),
            // TODO: Strings will have to be added to the data segment
            Literal::String(string) => panic!("Strings not yet supported"),
            Literal::Boolean(bool) => format!("({})", if *bool { 1 } else { 0 })
        }
    }

    fn generate_statement_assembly(
        &mut self,
        statement: Statement
    ) -> Result<(), AssemblyGenerationError> {
        match statement.get_identifier().as_str() {
            "fn" => self.generate_function_assembly(statement),
            name => {
                let mut operands = Vec::new();
                for expression in statement.get_expressions() {
                    match expression {
                        Expression::Literal(literal) => {
                            operands.push(self.format_literal(literal))
                        },
                        Expression::Identifier(identifier) => {
                            // TODO: dereference variables
                            return Err(NotImplemented);
                        },
                        Expression::Statement(_) => {
                            return Err(NotImplemented);
                        }
                    }
                }

                self.add_instruction(InstructionBuilder {
                    operator: name.to_string(),
                    operands
                });

                Ok(())
            },
            _ => Err(AssemblyGenerationError::NotImplemented)
        }
    }

    fn generate_function_assembly(
        &mut self,
        statement: Statement
    ) -> Result<(), AssemblyGenerationError> {
        if statement.get_identifier() != "fn" {
            return Err(AssemblyGenerationError::ExpectedSpecificStatement("fn".to_string()));
        }

        let mut expression_iter = statement.get_expressions().clone().into_iter();

        // Get the function name
        let name = match expression_iter.next() {
            Some(expression) => match expression {
                Expression::Identifier(s) => s,
                _ => return Err(AssemblyGenerationError::ExpectedIdentifierForFunctionName)
            },
            None => return Err(AssemblyGenerationError::ExpectedIdentifierForFunctionName)
        };
        println!("name: {}", name);

        // TODO: Figure out parameters

        // The rest of the expressions must be statements
        while let Some(next_expr) = expression_iter.next() {
            match next_expr {
                Expression::Statement(statement) => match statement.get_identifier().as_str() {
                    "fn" => return Err(AssemblyGenerationError::NestedFunctionNotAllowed),
                    _ => self.generate_statement_assembly(statement)?
                }
                _ => return Err(AssemblyGenerationError::ExpectedStatement)
            }
        }

        Err(AssemblyGenerationError::NotImplemented)
    }

    fn data_segment(&mut self) -> &mut DataSegmentBuilder {
        &mut self.data_segment
    }
}

impl InstructionBuilder {
    pub fn new(operator: String) -> InstructionBuilder {
        InstructionBuilder { operator, operands: Vec::new() }
    }

    pub fn add_operand(&mut self, operand: String) {
        self.operands.push(operand);
    }

    pub fn build_source(self) -> String {
        if self.operands.is_empty() {
            format!("{}", self.operator)
        } else {
            format!("{} {}", self.operator, self.operands.join(" "))
        }
    }
}

impl DataSegmentBuilder {
    pub fn new() -> DataSegmentBuilder {
        DataSegmentBuilder { data: Vec::new() }
    }

    pub fn add_data(&mut self, name: String, value: String) {
        self.data.push((name, value));
    }

    pub fn build_source(self) -> String {
        if self.data.is_empty() {
            return String::new();
        }

        let mut source = String::new();
        source.push_str(".section data\n");

        for (name, value) in self.data {
            source.push_str(&format!("  .{} \"{}\"\n", name, value));
        }

        source
    }
}

pub fn generate_assembly(ast: Ast) -> Result<AssemblyBuilder, AssemblyGenerationError> {
    let mut builder = AssemblyBuilder::new();

    for expression in ast.into_expressions() {
        match expression {
            Expression::Statement(statement) => {
                builder.generate_statement_assembly(statement)?;
            }
            _ => return Err(AssemblyGenerationError::ExpectedStatement)
        }
    }

    Ok(builder)
}
