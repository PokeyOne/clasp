// TODO: This whole file is going to need a major rewrite now that the ast has been
//       re-written.

#[cfg(test)]
mod tests;

mod clasp_std;

use crate::parsing::ast::{Ast, Expression, Literal};
use std::collections::HashSet;

#[derive(Debug, Clone, PartialEq)]
pub enum AssemblyGenerationError {
    ExpectedStatement,
    ExpectedSpecificStatement(String),
    ExpectedIdentifierForFunctionName,
    NestedFunctionNotAllowed,
    DuplicateFunctionName(String),
    DuplicateMainFunction,
    #[allow(dead_code)]
    NotImplemented
}
use AssemblyGenerationError::*;

/// Builds an assembly representation of the given AST.
pub struct AssemblyBuilder {
    /// The built instructions.
    instructions: Vec<InstructionBuilder>,
    /// The data constants.
    data_segment: DataSegmentBuilder,
    /// Names of functions that have been declared.
    declared_functions: HashSet<String>
}

pub struct InstructionBuilder {
    operator: String,
    operands: Vec<String>
}

struct DataSegmentBuilder {
    data: Vec<(String, String)> // name, value
}

impl AssemblyBuilder {
    /// Create a new empty assembly builder.
    pub fn new() -> AssemblyBuilder {
        AssemblyBuilder {
            instructions: Vec::new(),
            data_segment: DataSegmentBuilder::new(),
            declared_functions: HashSet::new()
        }
    }

    pub fn add_instruction(&mut self, instruction: InstructionBuilder) {
        self.instructions.push(instruction);
    }

    pub fn build_source(self) -> String {
        let mut source = String::new();
        source.push_str(";; Clasm program generated by Clasp Compiler\n");

        for instruction in &self.instructions {
            source.push_str(&format!("{}\n", instruction.build_source()));
        }

        // If there is a main function, then that function should have
        // a return statement at the end, and no need for an explicit end.
        if !self.has_main() {
            source.push_str("end\n");
        }

        source.push_str(&self.data_segment.build_source());

        source
    }

    fn has_main(&self) -> bool {
        self.declared_functions.contains("main")
    }

    fn format_literal(&mut self, literal: &Literal) -> String {
        todo!("update format_literal for new parser");
        /*
        match literal {
            Literal::Number(number) => format!("({})", number),
            Literal::String(string) => {
                let id = self.data_segment.register_data(string.clone());
                format!(".{}", id)
            }
            Literal::Boolean(bool) => format!("({})", if *bool { 1 } else { 0 })
        }
        */
    }

    // TODO: update generate_statement_assembly for new parser
    /*
    fn generate_statement_assembly(
        &mut self,
        statement: Statement
    ) -> Result<(), AssemblyGenerationError> {
        match statement.get_identifier().as_str() {
            "fn" => self.generate_function_assembly(statement),
            name => {
                let mut operands = Vec::new();
                // Call label
                operands.push(format!(":{}", name));

                // Call arguments
                for expression in statement.get_expressions() {
                    match expression {
                        Expression::Literal(literal) => operands.push(self.format_literal(literal)),
                        Expression::Identifier(identifier) => {
                            // TODO: dereference variables
                            println!("TODO: dereference variables");
                            return Err(NotImplemented);
                        }
                        Expression::Statement(_) => {
                            println!("TODO: expression statement");
                            return Err(NotImplemented);
                        }
                    }
                }

                self.add_instruction(InstructionBuilder {
                    operator: "call".to_string(),
                    operands
                });

                Ok(())
            }
        }
    }

    fn generate_function_assembly(
        &mut self,
        statement: Statement
    ) -> Result<(), AssemblyGenerationError> {
        // TODO: update generate_function_assembly for new parser
        if statement.get_identifier() != "fn" {
            return Err(AssemblyGenerationError::ExpectedSpecificStatement(
                "fn".to_string()
            ));
        }

        let mut expression_iter = statement.get_expressions().clone().into_iter();

        // Get the function name
        let name = match expression_iter.next() {
            Some(expression) => match expression {
                Expression::Identifier(s) => s,
                _ => return Err(ExpectedIdentifierForFunctionName)
            },
            None => return Err(ExpectedIdentifierForFunctionName)
        };
        if name == "main" {
            if self.has_main() {
                return Err(DuplicateMainFunction);
            }
            self.declared_functions.insert("main".to_string());
        }
        self.add_instruction(InstructionBuilder::new(format!(":{}", name)));

        // TODO: Figure out parameters

        // The rest of the expressions must be statements
        while let Some(next_expr) = expression_iter.next() {
            match next_expr {
                Expression::Statement(statement) => match statement.get_identifier().as_str() {
                    "fn" => return Err(AssemblyGenerationError::NestedFunctionNotAllowed),
                    _ => self.generate_statement_assembly(statement)?
                },
                _ => return Err(AssemblyGenerationError::ExpectedStatement)
            }
        }

        self.add_instruction(InstructionBuilder::new("return".to_string()));
        Ok(())
    }
     */
    fn data_segment(&mut self) -> &mut DataSegmentBuilder {
        &mut self.data_segment
    }
}

impl InstructionBuilder {
    pub fn new(operator: String) -> InstructionBuilder {
        InstructionBuilder {
            operator,
            operands: Vec::new()
        }
    }

    pub fn add_operand(&mut self, operand: String) {
        self.operands.push(operand);
    }

    pub fn build_source(&self) -> String {
        if self.operands.is_empty() {
            format!("{}", self.operator)
        } else {
            format!("{} {}", self.operator, self.operands.join(" "))
        }
    }
}

impl DataSegmentBuilder {
    /// Create a new empty data segment builder
    pub fn new() -> DataSegmentBuilder {
        DataSegmentBuilder { data: Vec::new() }
    }

    /// Adds data to the data segment by the given identifier. If the identifier
    /// already exists, it will be overwritten. If the identifier is not
    /// essential, the register_data function should be used instead.
    pub fn add_data(&mut self, name: String, value: String) {
        self.data.push((name, value));
    }

    /// Registers a string constant in the data segment.
    ///
    /// The name of the constant will be uniquely generated, and be returned
    /// from this function. The name will be of the from "d%04d".
    pub fn register_data(&mut self, value: String) -> String {
        let name = format!("d{:04}", self.data.len());
        self.add_data(name.clone(), value);
        name
    }

    /// Constructs the raw data segment as a string. This is the exact string
    /// that will be written to the output file.
    pub fn build_source(self) -> String {
        // We don't need any data segment if there is no data
        if self.data.is_empty() {
            return String::new();
        }

        // Create the string and the header
        let mut source = String::new();
        source.push_str(".section data\n");

        // Add each element of data to the string. Should already be sorted.
        for (name, value) in self.data {
            source.push_str(&format!("  .{} \"{}\"\n", name, value));
        }

        source
    }
}

/// Generates the assembly for a given abstract syntax tree. This will be
/// a full assembly file with all the necessary instructions and segments.
pub fn generate_assembly(ast: Ast) -> Result<AssemblyBuilder, AssemblyGenerationError> {
    let mut builder = AssemblyBuilder::new();

    todo!("rewrite generate_assembly for the new parser");
    /*
    for expression in ast.into_expressions() {
        match expression {
            Expression::Statement(statement) => {
                builder.generate_statement_assembly(statement)?;
            }
            _ => return Err(AssemblyGenerationError::ExpectedStatement)
        }
    }*/

    Ok(builder)
}
